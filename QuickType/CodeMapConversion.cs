using System;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using CodeMapConversion;
//
//    var codeMap = CodeMap.FromJson(jsonString);

namespace DGMLD3.QuickType.CodeMapConversion
{
    public partial class CodeMap
    {
        [JsonProperty("?xml")]
        public Xml Xml { get; set; }

        [JsonProperty("DirectedGraph")]
        public DirectedGraph DirectedGraph { get; set; }
    }

    public partial class DirectedGraph
    {
        [JsonProperty("@DataVirtualized")]
        public DataVirtualized DataVirtualized { get; set; }

        [JsonProperty("@GraphDirection")]
        public string GraphDirection { get; set; }

        [JsonProperty("@Layout")]
        public string Layout { get; set; }

        [JsonProperty("@ZoomLevel")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long ZoomLevel { get; set; }

        [JsonProperty("@xmlns")]
        public Uri Xmlns { get; set; }

        [JsonProperty("Nodes")]
        public Nodes Nodes { get; set; }

        [JsonProperty("Links")]
        public Links Links { get; set; }

        [JsonProperty("Categories")]
        public Categories Categories { get; set; }

        [JsonProperty("Properties")]
        public Properties Properties { get; set; }

        [JsonProperty("QualifiedNames")]
        public QualifiedNames QualifiedNames { get; set; }

        [JsonProperty("IdentifierAliases")]
        public IdentifierAliases IdentifierAliases { get; set; }

        [JsonProperty("Styles")]
        public Styles Styles { get; set; }

        [JsonProperty("Paths")]
        public Paths Paths { get; set; }
    }

    public partial class Categories
    {
        [JsonProperty("Category")]
        public CategoriesCategory[] Category { get; set; }
    }

    public partial class CategoriesCategory
    {
        [JsonProperty("@Id")]
        public string Id { get; set; }

        [JsonProperty("@Label", NullValueHandling = NullValueHandling.Ignore)]
        public string Label { get; set; }

        [JsonProperty("@CanBeDataDriven")]
        public DataVirtualized CanBeDataDriven { get; set; }

        [JsonProperty("@CanLinkedNodesBeDataDriven", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CanLinkedNodesBeDataDriven { get; set; }

        [JsonProperty("@IncomingActionLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string IncomingActionLabel { get; set; }

        [JsonProperty("@OutgoingActionLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string OutgoingActionLabel { get; set; }

        [JsonProperty("@IsProviderRoot", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? IsProviderRoot { get; set; }

        [JsonProperty("@NavigationActionLabel", NullValueHandling = NullValueHandling.Ignore)]
        public string NavigationActionLabel { get; set; }

        [JsonProperty("@BasedOn", NullValueHandling = NullValueHandling.Ignore)]
        public string BasedOn { get; set; }

        [JsonProperty("@DefaultAction", NullValueHandling = NullValueHandling.Ignore)]
        public string DefaultAction { get; set; }

        [JsonProperty("@Icon", NullValueHandling = NullValueHandling.Ignore)]
        public Icon? Icon { get; set; }

        [JsonProperty("@Description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }

        [JsonProperty("@IsContainment", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? IsContainment { get; set; }
    }

    public partial class IdentifierAliases
    {
        [JsonProperty("Alias")]
        public Alias[] Alias { get; set; }
    }

    public partial class Alias
    {
        [JsonProperty("@n")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long N { get; set; }

        [JsonProperty("@Uri", NullValueHandling = NullValueHandling.Ignore)]
        public string Uri { get; set; }

        [JsonProperty("@Id", NullValueHandling = NullValueHandling.Ignore)]
        public string Id { get; set; }
    }

    public partial class Links
    {
        [JsonProperty("Link")]
        public Link[] Link { get; set; }
    }

    public partial class Link
    {
        [JsonProperty("@Source")]
        public string Source { get; set; }

        [JsonProperty("@Target")]
        public string Target { get; set; }

        [JsonProperty("@Category")]
        public Category Category { get; set; }

        [JsonProperty("@IsSourceVirtualized", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? IsSourceVirtualized { get; set; }

        [JsonProperty("@IsTargetVirtualized", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? IsTargetVirtualized { get; set; }

        [JsonProperty("@Weight", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(ParseStringConverter))]
        public long? Weight { get; set; }

        [JsonProperty("Category", NullValueHandling = NullValueHandling.Ignore)]
        public CategoryUnion? LinkCategory { get; set; }

        [JsonProperty("@Bounds", NullValueHandling = NullValueHandling.Ignore)]
        public string Bounds { get; set; }

        [JsonProperty("@FetchingParent", NullValueHandling = NullValueHandling.Ignore)]
        public string FetchingParent { get; set; }
    }

    public partial class CategoryCategory
    {
        [JsonProperty("@Ref")]
        public Ref Ref { get; set; }
    }

    public partial class Nodes
    {
        [JsonProperty("Node")]
        public Node[] Node { get; set; }
    }

    public partial class Node
    {
        [JsonProperty("@Id")]
        public string Id { get; set; }

        [JsonProperty("@Category")]
        public Icon Category { get; set; }

        [JsonProperty("@Bounds")]
        public string Bounds { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsConstructor", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsConstructor { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsPublic", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsPublic { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsSpecialName", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsSpecialName { get; set; }

        [JsonProperty("@DelayedCrossGroupLinksState", NullValueHandling = NullValueHandling.Ignore)]
        public DelayedCsState? DelayedCrossGroupLinksState { get; set; }

        [JsonProperty("@Label")]
        public string Label { get; set; }

        [JsonProperty("@DelayedChildNodesState", NullValueHandling = NullValueHandling.Ignore)]
        public DelayedCsState? DelayedChildNodesState { get; set; }

        [JsonProperty("@FilePath", NullValueHandling = NullValueHandling.Ignore)]
        public string FilePath { get; set; }

        [JsonProperty("@Group", NullValueHandling = NullValueHandling.Ignore)]
        public Group? Group { get; set; }

        [JsonProperty("@UseManualLocation", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? UseManualLocation { get; set; }

        [JsonProperty("@FetchedChildrenCount", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(ParseStringConverter))]
        public long? FetchedChildrenCount { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsAbstract", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsAbstract { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsInternal", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsInternal { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsFinal", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsFinal { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsPrivate", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsPrivate { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsStatic", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsStatic { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsHideBySignature", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsHideBySignature { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsProtected", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsProtected { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsVirtual", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsVirtual { get; set; }

        [JsonProperty("@CodeSchemaProperty_IsExternal", NullValueHandling = NullValueHandling.Ignore)]
        public DataVirtualized? CodeSchemaPropertyIsExternal { get; set; }

        [JsonProperty("@CodeSchemaProperty_StrongName", NullValueHandling = NullValueHandling.Ignore)]
        public string CodeSchemaPropertyStrongName { get; set; }

        [JsonProperty("Category", NullValueHandling = NullValueHandling.Ignore)]
        public CategoryUnion? NodeCategory { get; set; }

        [JsonProperty("@LayoutSettings", NullValueHandling = NullValueHandling.Ignore)]
        public string LayoutSettings { get; set; }
    }

    public partial class Paths
    {
        [JsonProperty("Path")]
        public Path[] Path { get; set; }
    }

    public partial class Path
    {
        [JsonProperty("@Id")]
        public string Id { get; set; }

        [JsonProperty("@Value")]
        public string Value { get; set; }
    }

    public partial class Properties
    {
        [JsonProperty("Property")]
        public Property[] Property { get; set; }
    }

    public partial class Property
    {
        [JsonProperty("@Id")]
        public string Id { get; set; }

        [JsonProperty("@DataType")]
        public string DataType { get; set; }

        [JsonProperty("@Label", NullValueHandling = NullValueHandling.Ignore)]
        public string Label { get; set; }

        [JsonProperty("@Description", NullValueHandling = NullValueHandling.Ignore)]
        public string Description { get; set; }
    }

    public partial class QualifiedNames
    {
        [JsonProperty("Name")]
        public Name[] Name { get; set; }
    }

    public partial class Name
    {
        [JsonProperty("@Id")]
        public string Id { get; set; }

        [JsonProperty("@Label")]
        public string Label { get; set; }

        [JsonProperty("@ValueType")]
        public string ValueType { get; set; }

        [JsonProperty("@Formatter", NullValueHandling = NullValueHandling.Ignore)]
        public string Formatter { get; set; }
    }

    public partial class Styles
    {
        [JsonProperty("Style")]
        public Style[] Style { get; set; }
    }

    public partial class Style
    {
        [JsonProperty("@TargetType")]
        public TargetType TargetType { get; set; }

        [JsonProperty("@GroupLabel")]
        public string GroupLabel { get; set; }

        [JsonProperty("@ValueLabel")]
        public string ValueLabel { get; set; }

        [JsonProperty("Condition")]
        public Condition Condition { get; set; }

        [JsonProperty("Setter", NullValueHandling = NullValueHandling.Ignore)]
        public SetterUnion? Setter { get; set; }

        [JsonProperty("@Visibility", NullValueHandling = NullValueHandling.Ignore)]
        public Visibility? Visibility { get; set; }
    }

    public partial class Condition
    {
        [JsonProperty("@Expression")]
        public string Expression { get; set; }
    }

    public partial class SetterElement
    {
        [JsonProperty("@Property")]
        public PropertyEnum Property { get; set; }

        [JsonProperty("@Value")]
        public string Value { get; set; }
    }

    public partial class Xml
    {
        [JsonProperty("@version")]
        public string Version { get; set; }

        [JsonProperty("@encoding")]
        public string Encoding { get; set; }
    }

    public enum DataVirtualized { False, True };

    public enum Icon { CodeMapProject, CodeMapSolutionFolder, CodeSchemaAssembly, CodeSchemaClass, CodeSchemaEnum, CodeSchemaField, CodeSchemaInterface, CodeSchemaMethod, CodeSchemaNamespace, CodeSchemaProperty, Externals, File, CodeStruct };

    public enum Category { CodeMapExternalReference, CodeMapProjectReference, CodeSchemaAttributeUse, CodeSchemaCalls, CodeSchemaFieldRead, CodeSchemaFieldWrite, CodeSchemaFunctionPointer, CodeSchemaReturnTypeLink, Contains, Implements, InheritsFrom, References };

    public enum Ref { CodeMapTestAsset, CodeMapTestProject, CodeMapWebProject, CodeSchemaAttributeUse, CodeSchemaCalls, CodeSchemaFieldRead, CodeSchemaFieldWrite, CodeSchemaReturnTypeLink, FileSystemCategoryFileOfTypeDll, Implements, InheritsFrom, References, CodeSchemaFunctionPointer };

    public enum DelayedCsState { Fetched, NotFetched };

    public enum Group { Collapsed, Expanded };

    public enum PropertyEnum { Background, DrawArrow, Icon, IndicatorWest, IsHidden, LayoutSettings, Stroke, StrokeDashArray, TargetDecorator };

    public enum TargetType { Link, Node };

    public enum Visibility { Hidden };

    public partial struct CategoryUnion
    {
        public CategoryCategory CategoryCategory;
        public CategoryCategory[] CategoryCategoryArray;

        public static implicit operator CategoryUnion(CategoryCategory CategoryCategory) => new CategoryUnion { CategoryCategory = CategoryCategory };
        public static implicit operator CategoryUnion(CategoryCategory[] CategoryCategoryArray) => new CategoryUnion { CategoryCategoryArray = CategoryCategoryArray };
    }

    public partial struct SetterUnion
    {
        public SetterElement SetterElement;
        public SetterElement[] SetterElementArray;

        public static implicit operator SetterUnion(SetterElement SetterElement) => new SetterUnion { SetterElement = SetterElement };
        public static implicit operator SetterUnion(SetterElement[] SetterElementArray) => new SetterUnion { SetterElementArray = SetterElementArray };
    }

    public partial class CodeMap
    {
        public static CodeMap FromJson(string json) => JsonConvert.DeserializeObject<CodeMap>(json, CodeMapConversion.Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this CodeMap self) => JsonConvert.SerializeObject(self, CodeMapConversion.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                DataVirtualizedConverter.Singleton,
                IconConverter.Singleton,
                CategoryConverter.Singleton,
                CategoryUnionConverter.Singleton,
                RefConverter.Singleton,
                DelayedCsStateConverter.Singleton,
                GroupConverter.Singleton,
                TargetTypeConverter.Singleton,
                VisibilityConverter.Singleton,
                SetterUnionConverter.Singleton,
                PropertyEnumConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class DataVirtualizedConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DataVirtualized) || t == typeof(DataVirtualized?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "False":
                    return DataVirtualized.False;
                case "True":
                    return DataVirtualized.True;
                default:
                    break;
            }
            throw new Exception("Cannot unmarshal type DataVirtualized");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DataVirtualized)untypedValue;
            switch (value)
            {
                case DataVirtualized.False:
                    serializer.Serialize(writer, "False");
                    return;
                case DataVirtualized.True:
                    serializer.Serialize(writer, "True");
                    return;
            }
            throw new Exception("Cannot marshal type DataVirtualized");
        }

        public static readonly DataVirtualizedConverter Singleton = new DataVirtualizedConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class IconConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Icon) || t == typeof(Icon?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            return value switch
            {
                "CodeMap_Project" => Icon.CodeMapProject,
                "CodeMap_SolutionFolder" => Icon.CodeMapSolutionFolder,
                "CodeSchema_Assembly" => Icon.CodeSchemaAssembly,
                "CodeSchema_Class" => Icon.CodeSchemaClass,
                "CodeSchema_Enum" => Icon.CodeSchemaEnum,
                "CodeSchema_Field" => Icon.CodeSchemaField,
                "CodeSchema_Interface" => Icon.CodeSchemaInterface,
                "CodeSchema_Method" => Icon.CodeSchemaMethod,
                "CodeSchema_Namespace" => Icon.CodeSchemaNamespace,
                "CodeSchema_Property" => Icon.CodeSchemaProperty,
                "CodeSchema_Struct" => Icon.CodeStruct,
                "Externals" => Icon.Externals,
                "File" => Icon.File,
                _ => throw new Exception("Cannot unmarshal type Icon"),
            };
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Icon)untypedValue;
            switch (value)
            {
                case Icon.CodeMapProject:
                    serializer.Serialize(writer, "CodeMap_Project");
                    return;
                case Icon.CodeMapSolutionFolder:
                    serializer.Serialize(writer, "CodeMap_SolutionFolder");
                    return;
                case Icon.CodeSchemaAssembly:
                    serializer.Serialize(writer, "CodeSchema_Assembly");
                    return;
                case Icon.CodeSchemaClass:
                    serializer.Serialize(writer, "CodeSchema_Class");
                    return;
                case Icon.CodeSchemaEnum:
                    serializer.Serialize(writer, "CodeSchema_Enum");
                    return;
                case Icon.CodeSchemaField:
                    serializer.Serialize(writer, "CodeSchema_Field");
                    return;
                case Icon.CodeSchemaInterface:
                    serializer.Serialize(writer, "CodeSchema_Interface");
                    return;
                case Icon.CodeSchemaMethod:
                    serializer.Serialize(writer, "CodeSchema_Method");
                    return;
                case Icon.CodeSchemaNamespace:
                    serializer.Serialize(writer, "CodeSchema_Namespace");
                    return;
                case Icon.CodeSchemaProperty:
                    serializer.Serialize(writer, "CodeSchema_Property");
                    return;
                case Icon.Externals:
                    serializer.Serialize(writer, "Externals");
                    return;
                case Icon.File:
                    serializer.Serialize(writer, "File");
                    return;
            }
            throw new Exception("Cannot marshal type Icon");
        }

        public static readonly IconConverter Singleton = new IconConverter();
    }

    internal class CategoryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Category) || t == typeof(Category?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            return value switch
            {
                "CodeMap_ExternalReference" => Category.CodeMapExternalReference,
                "CodeMap_ProjectReference" => Category.CodeMapProjectReference,
                "CodeSchema_AttributeUse" => Category.CodeSchemaAttributeUse,
                "CodeSchema_Calls" => Category.CodeSchemaCalls,
                "CodeSchema_FieldRead" => Category.CodeSchemaFieldRead,
                "CodeSchema_FieldWrite" => Category.CodeSchemaFieldWrite,
                "CodeSchema_FunctionPointer" => Category.CodeSchemaFunctionPointer,
                "CodeSchema_ReturnTypeLink" => Category.CodeSchemaReturnTypeLink,
                "Contains" => Category.Contains,
                "Implements" => Category.Implements,
                "InheritsFrom" => Category.InheritsFrom,
                "References" => Category.References,
                _ => throw new Exception("Cannot unmarshal type Category"),
            };
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Category)untypedValue;
            switch (value)
            {
                case Category.CodeMapExternalReference:
                    serializer.Serialize(writer, "CodeMap_ExternalReference");
                    return;
                case Category.CodeMapProjectReference:
                    serializer.Serialize(writer, "CodeMap_ProjectReference");
                    return;
                case Category.CodeSchemaAttributeUse:
                    serializer.Serialize(writer, "CodeSchema_AttributeUse");
                    return;
                case Category.CodeSchemaCalls:
                    serializer.Serialize(writer, "CodeSchema_Calls");
                    return;
                case Category.CodeSchemaFieldRead:
                    serializer.Serialize(writer, "CodeSchema_FieldRead");
                    return;
                case Category.CodeSchemaFieldWrite:
                    serializer.Serialize(writer, "CodeSchema_FieldWrite");
                    return;
                case Category.CodeSchemaFunctionPointer:
                    serializer.Serialize(writer, "CodeSchema_FunctionPointer");
                    return;
                case Category.CodeSchemaReturnTypeLink:
                    serializer.Serialize(writer, "CodeSchema_ReturnTypeLink");
                    return;
                case Category.Contains:
                    serializer.Serialize(writer, "Contains");
                    return;
                case Category.Implements:
                    serializer.Serialize(writer, "Implements");
                    return;
                case Category.InheritsFrom:
                    serializer.Serialize(writer, "InheritsFrom");
                    return;
                case Category.References:
                    serializer.Serialize(writer, "References");
                    return;
            }
            throw new Exception("Cannot marshal type Category");
        }

        public static readonly CategoryConverter Singleton = new CategoryConverter();
    }

    internal class CategoryUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CategoryUnion) || t == typeof(CategoryUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<CategoryCategory>(reader);
                    return new CategoryUnion { CategoryCategory = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<CategoryCategory[]>(reader);
                    return new CategoryUnion { CategoryCategoryArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type CategoryUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (CategoryUnion)untypedValue;
            if (value.CategoryCategoryArray != null)
            {
                serializer.Serialize(writer, value.CategoryCategoryArray);
                return;
            }
            if (value.CategoryCategory != null)
            {
                serializer.Serialize(writer, value.CategoryCategory);
                return;
            }
            throw new Exception("Cannot marshal type CategoryUnion");
        }

        public static readonly CategoryUnionConverter Singleton = new CategoryUnionConverter();
    }

    internal class RefConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Ref) || t == typeof(Ref?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            return value switch
            {
                "CodeMap_TestAsset" => Ref.CodeMapTestAsset,
                "CodeMap_TestProject" => Ref.CodeMapTestProject,
                "CodeMap_WebProject" => Ref.CodeMapWebProject,
                "CodeSchema_AttributeUse" => Ref.CodeSchemaAttributeUse,
                "CodeSchema_Calls" => Ref.CodeSchemaCalls,
                "CodeSchema_FieldRead" => Ref.CodeSchemaFieldRead,
                "CodeSchema_FieldWrite" => Ref.CodeSchemaFieldWrite,
                "CodeSchema_ReturnTypeLink" => Ref.CodeSchemaReturnTypeLink,
                "FileSystem.Category.FileOfType.dll" => Ref.FileSystemCategoryFileOfTypeDll,
                "Implements" => Ref.Implements,
                "InheritsFrom" => Ref.InheritsFrom,
                "References" => Ref.References,
                "CodeSchema_FunctionPointer" => Ref.CodeSchemaFunctionPointer,
                _ => throw new Exception("Cannot unmarshal type Ref"),
            };
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Ref)untypedValue;
            switch (value)
            {
                case Ref.CodeMapTestAsset:
                    serializer.Serialize(writer, "CodeMap_TestAsset");
                    return;
                case Ref.CodeMapTestProject:
                    serializer.Serialize(writer, "CodeMap_TestProject");
                    return;
                case Ref.CodeMapWebProject:
                    serializer.Serialize(writer, "CodeMap_WebProject");
                    return;
                case Ref.CodeSchemaAttributeUse:
                    serializer.Serialize(writer, "CodeSchema_AttributeUse");
                    return;
                case Ref.CodeSchemaCalls:
                    serializer.Serialize(writer, "CodeSchema_Calls");
                    return;
                case Ref.CodeSchemaFieldRead:
                    serializer.Serialize(writer, "CodeSchema_FieldRead");
                    return;
                case Ref.CodeSchemaFieldWrite:
                    serializer.Serialize(writer, "CodeSchema_FieldWrite");
                    return;
                case Ref.CodeSchemaReturnTypeLink:
                    serializer.Serialize(writer, "CodeSchema_ReturnTypeLink");
                    return;
                case Ref.FileSystemCategoryFileOfTypeDll:
                    serializer.Serialize(writer, "FileSystem.Category.FileOfType.dll");
                    return;
                case Ref.Implements:
                    serializer.Serialize(writer, "Implements");
                    return;
                case Ref.InheritsFrom:
                    serializer.Serialize(writer, "InheritsFrom");
                    return;
                case Ref.References:
                    serializer.Serialize(writer, "References");
                    return;
            }
            throw new Exception("Cannot marshal type Ref");
        }

        public static readonly RefConverter Singleton = new RefConverter();
    }

    internal class DelayedCsStateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DelayedCsState) || t == typeof(DelayedCsState?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            return value switch
            {
                "Fetched" => DelayedCsState.Fetched,
                "NotFetched" => DelayedCsState.NotFetched,
                _ => throw new Exception("Cannot unmarshal type DelayedCsState"),
            };
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DelayedCsState)untypedValue;
            switch (value)
            {
                case DelayedCsState.Fetched:
                    serializer.Serialize(writer, "Fetched");
                    return;
                case DelayedCsState.NotFetched:
                    serializer.Serialize(writer, "NotFetched");
                    return;
            }
            throw new Exception("Cannot marshal type DelayedCsState");
        }

        public static readonly DelayedCsStateConverter Singleton = new DelayedCsStateConverter();
    }

    internal class GroupConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Group) || t == typeof(Group?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            return value switch
            {
                "Collapsed" => Group.Collapsed,
                "Expanded" => Group.Expanded,
                _ => throw new Exception("Cannot unmarshal type Group"),
            };
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Group)untypedValue;
            switch (value)
            {
                case Group.Collapsed:
                    serializer.Serialize(writer, "Collapsed");
                    return;
                case Group.Expanded:
                    serializer.Serialize(writer, "Expanded");
                    return;
            }
            throw new Exception("Cannot marshal type Group");
        }

        public static readonly GroupConverter Singleton = new GroupConverter();
    }

    internal class TargetTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TargetType) || t == typeof(TargetType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            return value switch
            {
                "Link" => TargetType.Link,
                "Node" => TargetType.Node,
                _ => throw new Exception("Cannot unmarshal type TargetType"),
            };
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (TargetType)untypedValue;
            switch (value)
            {
                case TargetType.Link:
                    serializer.Serialize(writer, "Link");
                    return;
                case TargetType.Node:
                    serializer.Serialize(writer, "Node");
                    return;
            }
            throw new Exception("Cannot marshal type TargetType");
        }

        public static readonly TargetTypeConverter Singleton = new TargetTypeConverter();
    }

    internal class VisibilityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Visibility) || t == typeof(Visibility?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Hidden")
            {
                return Visibility.Hidden;
            }
            throw new Exception("Cannot unmarshal type Visibility");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Visibility)untypedValue;
            if (value == Visibility.Hidden)
            {
                serializer.Serialize(writer, "Hidden");
                return;
            }
            throw new Exception("Cannot marshal type Visibility");
        }

        public static readonly VisibilityConverter Singleton = new VisibilityConverter();
    }

    internal class SetterUnionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(SetterUnion) || t == typeof(SetterUnion?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<SetterElement>(reader);
                    return new SetterUnion { SetterElement = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<SetterElement[]>(reader);
                    return new SetterUnion { SetterElementArray = arrayValue };
            }
            throw new Exception("Cannot unmarshal type SetterUnion");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (SetterUnion)untypedValue;
            if (value.SetterElementArray != null)
            {
                serializer.Serialize(writer, value.SetterElementArray);
                return;
            }
            if (value.SetterElement != null)
            {
                serializer.Serialize(writer, value.SetterElement);
                return;
            }
            throw new Exception("Cannot marshal type SetterUnion");
        }

        public static readonly SetterUnionConverter Singleton = new SetterUnionConverter();
    }

    internal class PropertyEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(PropertyEnum) || t == typeof(PropertyEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            return value switch
            {
                "Background" => PropertyEnum.Background,
                "DrawArrow" => PropertyEnum.DrawArrow,
                "Icon" => PropertyEnum.Icon,
                "IndicatorWest" => PropertyEnum.IndicatorWest,
                "IsHidden" => PropertyEnum.IsHidden,
                "LayoutSettings" => PropertyEnum.LayoutSettings,
                "Stroke" => PropertyEnum.Stroke,
                "StrokeDashArray" => PropertyEnum.StrokeDashArray,
                "TargetDecorator" => PropertyEnum.TargetDecorator,
                _ => throw new Exception("Cannot unmarshal type PropertyEnum"),
            };
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (PropertyEnum)untypedValue;
            switch (value)
            {
                case PropertyEnum.Background:
                    serializer.Serialize(writer, "Background");
                    return;
                case PropertyEnum.DrawArrow:
                    serializer.Serialize(writer, "DrawArrow");
                    return;
                case PropertyEnum.Icon:
                    serializer.Serialize(writer, "Icon");
                    return;
                case PropertyEnum.IndicatorWest:
                    serializer.Serialize(writer, "IndicatorWest");
                    return;
                case PropertyEnum.IsHidden:
                    serializer.Serialize(writer, "IsHidden");
                    return;
                case PropertyEnum.LayoutSettings:
                    serializer.Serialize(writer, "LayoutSettings");
                    return;
                case PropertyEnum.Stroke:
                    serializer.Serialize(writer, "Stroke");
                    return;
                case PropertyEnum.StrokeDashArray:
                    serializer.Serialize(writer, "StrokeDashArray");
                    return;
                case PropertyEnum.TargetDecorator:
                    serializer.Serialize(writer, "TargetDecorator");
                    return;
            }
            throw new Exception("Cannot marshal type PropertyEnum");
        }

        public static readonly PropertyEnumConverter Singleton = new PropertyEnumConverter();
    }
}

